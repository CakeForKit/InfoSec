\chapter{Теоретическая часть}

Виды симметричного шифрования:
\begin{enumerate}[label={\arabic*)}]
	\item Поточные: Шифруют данные побитово/побайтово (RC4);
	\item Блочные: Шифруют данные блоками фиксированного размера (DES, AES);	
\end{enumerate}

Алгоритмы перестановки — это методы, которые изменяют порядок следования элементов (но не их значения) посредством присваивания и перестановки их значений. Пример: IP в DES.

Алгоритмы подстановки — это методы шифрования, в которых элементы исходного открытого текста заменяются зашифрованным текстом в соответствии с некоторым правилом. Пример: шифр Цезаря.

Алгоритм DES использует методы перестановки и подстановки.

\chapter{Описание алгоритма симметричного шифрования (DES)}

На рисунке~\ref{img:img/genKeys} приведена схема генерации подключей, которая выполняется перед началом шифрования по алгоритму DES.

\FloatBarrier
\imgw{0.6\textwidth}{img/genKeys}{Схема генерации генерации подключей}
\FloatBarrier

\clearpage
На рисунке~\ref{img:img/des} приведена схема алгоритма симметричного шифрования (DES).

\FloatBarrier
\imgw{0.7\textwidth}{img/des}{Схема алгоритма симметричного шифрования (DES)}
\FloatBarrier



\chapter{Пример работы алгоритма симметричного шифрования (DES)}

На рисунке~\ref{img:img/example} приведен пример работы алгоритма симметричного шифрования (DES).

\FloatBarrier
\imgw{1\textwidth}{img/example}{Пример работы алгоритма симметричного шифрования (DES)}
\FloatBarrier

\clearpage
На рисунках~\ref{img:img/text_1}-\ref{img:img/text_2} приведен пример работы алгоритма шифрования и расшифровки с открытым ключом файла при попытке расшифровки файла сторонним ключом.

\FloatBarrier
\imgw{1\textwidth}{img/text_1}{Содержимое файла для шифрования и зашифрованного файла}
\FloatBarrier
\imgw{1\textwidth}{img/text_2}{Содержимое файла для расшифрованного файла}
\FloatBarrier

\chapter{Реализация алгоритма симметричного шифрования (DES)}
В качестве средства реализации алгоритма симметричного шифрования (DES) был выбран язык Go.

\begin{lstlisting}[style=golang, caption={Реализация алгоритма шифрования и расшифровки с открытым ключом файла}, label=lst:codegolang]
type DES struct {
	subkeys [16]uint64
}

func NewDES(key uint64) *DES {
	des := &DES{}
	des.generateSubkeys(key)
	return des
}

func initialPermutation(block uint64) uint64 {
	ipTable := [64]int{
		58, 50, 42, 34, 26, 18, 10, 2,
		60, 52, 44, 36, 28, 20, 12, 4,
		62, 54, 46, 38, 30, 22, 14, 6,
		64, 56, 48, 40, 32, 24, 16, 8,
		57, 49, 41, 33, 25, 17, 9, 1,
		59, 51, 43, 35, 27, 19, 11, 3,
		61, 53, 45, 37, 29, 21, 13, 5,
		63, 55, 47, 39, 31, 23, 15, 7,
	}
	return permute(block, ipTable[:], 64)
}

func finalPermutation(block uint64) uint64 {
	fpTable := [64]int{
		40, 8, 48, 16, 56, 24, 64, 32,
		39, 7, 47, 15, 55, 23, 63, 31,
		38, 6, 46, 14, 54, 22, 62, 30,
		37, 5, 45, 13, 53, 21, 61, 29,
		36, 4, 44, 12, 52, 20, 60, 28,
		35, 3, 43, 11, 51, 19, 59, 27,
		34, 2, 42, 10, 50, 18, 58, 26,
		33, 1, 41, 9, 49, 17, 57, 25,
	}
	return permute(block, fpTable[:], 64)
}

func expansionPermutation(right uint32) uint64 {
	eTable := [48]int{
		32, 1, 2, 3, 4, 5,
		4, 5, 6, 7, 8, 9,
		8, 9, 10, 11, 12, 13,
		12, 13, 14, 15, 16, 17,
		16, 17, 18, 19, 20, 21,
		20, 21, 22, 23, 24, 25,
		24, 25, 26, 27, 28, 29,
		28, 29, 30, 31, 32, 1,
	}
	return uint64(permute32(uint64(right), eTable[:], 32))
}

func pPermutation(data uint32) uint32 {
	pTable := [32]int{
		16, 7, 20, 21, 29, 12, 28, 17,
		1, 15, 23, 26, 5, 18, 31, 10,
		2, 8, 24, 14, 32, 27, 3, 9,
		19, 13, 30, 6, 22, 11, 4, 25,
	}
	return uint32(permute32(uint64(data), pTable[:], 32))
}

func sBoxSubstitution(data uint64) uint32 {
	sBoxes := [8][4][16]uint8{
	// S1
	{
		{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
		{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
		{4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
		{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13},
	},
	// S2
	{
		{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},
		{3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
		{0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
		{13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9},
	},
	// S3
	{
		{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},
		{13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
		{13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
		{1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12},
	},
	// S4
	{
		{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
		{13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},
		{10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
		{3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14},
	},
	// S5
	{
		{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
		{14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},
		{4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
		{11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3},
	},
	// S6
	{
		{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
		{10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},
		{9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
		{4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13},
	},
	// S7
	{
		{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
		{13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},
		{1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
		{6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12},
	},
	// S8
	{
		{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
		{1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
		{7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},
		{2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11},
	},
	}
	
	var result uint32
	for i := 0; i < 8; i++ {
		chunk := (data >> (42 - 6*i)) & 0x3F
		row := ((chunk & 0x20) >> 4) | (chunk & 0x01)
		col := (chunk >> 1) & 0x0F
		sVal := sBoxes[i][row][col]
		result = (result << 4) | uint32(sVal)
	}
	
	return result
}

func feistelFunction(right uint32, subkey uint64) uint32 {
	expanded := expansionPermutation(right)
	xored := expanded ^ subkey
	substituted := sBoxSubstitution(xored)
	return pPermutation(substituted)
}

func (des *DES) generateSubkeys(key uint64) {
	pc1Table := [56]int{
		57, 49, 41, 33, 25, 17, 9, 1,
		58, 50, 42, 34, 26, 18, 10, 2,
		59, 51, 43, 35, 27, 19, 11, 3,
		60, 52, 44, 36, 63, 55, 47, 39,
		31, 23, 15, 7, 62, 54, 46, 38,
		30, 22, 14, 6, 61, 53, 45, 37,
		29, 21, 13, 5, 28, 20, 12, 4,
	}
	pc2Table := [48]int{
		14, 17, 11, 24, 1, 5, 3, 28,
		15, 6, 21, 10, 23, 19, 12, 4,
		26, 8, 16, 7, 27, 20, 13, 2,
		41, 52, 31, 37, 47, 55, 30, 40,
		51, 45, 33, 48, 44, 49, 39, 56,
		34, 53, 46, 42, 50, 36, 29, 32,
	}
	shifts := [16]int{1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}
	
	permutedKey := permute(key, pc1Table[:], 64)
	
	c := (permutedKey >> 28) & 0x0FFFFFFF
	d := permutedKey & 0x0FFFFFFF
	
	for i := 0; i < 16; i++ {
		c = ((c << shifts[i]) | (c >> (28 - shifts[i]))) & 0x0FFFFFFF
		d = ((d << shifts[i]) | (d >> (28 - shifts[i]))) & 0x0FFFFFFF
		
		combined := (c << 28) | d
		des.subkeys[i] = permute(combined, pc2Table[:], 56)
	}
}

func (d *DES) encryptBlock(block uint64) uint64 {
	block = initialPermutation(block)
	
	left := uint32(block >> 32)
	right := uint32(block & 0xFFFFFFFF)
	
	for i := 0; i < 16; i++ {
		nextLeft := right
		fResult := feistelFunction(right, d.subkeys[i])
		nextRight := left ^ fResult
		
		left = nextLeft
		right = nextRight
	}
	
	combined := (uint64(right) << 32) | uint64(left)
	
	return finalPermutation(combined)
}

func (d *DES) decryptBlock(block uint64) uint64 {
	temp := d.subkeys
	for i := 0; i < 8; i++ {
		d.subkeys[i], d.subkeys[15-i] = d.subkeys[15-i], d.subkeys[i]
	}
	result := d.encryptBlock(block)
	d.subkeys = temp
	
	return result
}

func permute(data uint64, table []int, inputSize int) uint64 {
	var result uint64
	for i, pos := range table {
		bit := (data >> (inputSize - pos)) & 1
		result |= bit << (uint(len(table)) - 1 - uint(i))
	}
	return result
}

func permute32(data uint64, table []int, inputSize int) uint64 {
	var result uint64
	for i, pos := range table {
		bit := (data >> (inputSize - pos)) & 1
		result |= bit << (uint(len(table)) - 1 - uint(i))
	}
	return result
}

func (d *DES) encryptFile(inputPath, outputPath string) error {
	inputFile, err := os.Open(inputPath)
	if err != nil {
		return err
	}
	defer inputFile.Close()
	
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer outputFile.Close()
	
	buffer := make([]byte, 8)
	for {
		n, err := inputFile.Read(buffer)
		if err != nil && err != io.EOF {
			return err
		}
		if n == 0 {
			break
		}
		if n < 8 {
			for i := n; i < 8; i++ {
				buffer[i] = 0 
			}
		}
		block := binary.BigEndian.Uint64(buffer)
		encryptedBlock := d.encryptBlock(block)
		encryptedBytes := make([]byte, 8)
		binary.BigEndian.PutUint64(encryptedBytes, encryptedBlock)
		_, err = outputFile.Write(encryptedBytes)
		if err != nil {
			return err
		}
		if err == io.EOF {
			break
		}
	}
	return nil
}


func (d *DES) decryptFile(inputPath, outputPath string) error {
	inputFile, err := os.Open(inputPath)
	if err != nil {
		return err
	}
	defer inputFile.Close()
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer outputFile.Close()
	buffer := make([]byte, 8)
	for {
		n, err := inputFile.Read(buffer)
		if err != nil && err != io.EOF {
			return err
		}
		if n == 0 {
			break
		}
		block := binary.BigEndian.Uint64(buffer)
		decryptedBlock := d.decryptBlock(block)
		decryptedBytes := make([]byte, 8)
		binary.BigEndian.PutUint64(decryptedBytes, decryptedBlock)
		
		if err == io.EOF || n < 8 {
			decryptedBytes = decryptedBytes[:n]
		}
		_, err = outputFile.Write(decryptedBytes)
		if err != nil {
			return err
		}
		if err == io.EOF {
			break
		}
	}
	return nil
}

func readKeyFromFile(keyFilePath string) (uint64, error) {
	keyData, err := os.ReadFile(keyFilePath)
	if err != nil {
		return 0, fmt.Errorf("error: %v", err)
	}
	keyStr := strings.TrimSpace(string(keyData))
	keyStr = strings.ReplaceAll(keyStr, " ", "")
	keyStr = strings.ReplaceAll(keyStr, "\n", "")
	keyStr = strings.ReplaceAll(keyStr, "\r", "")
	keyStr = strings.ReplaceAll(keyStr, "0x", "")
	keyStr = strings.ReplaceAll(keyStr, "0X", "")
	if len(keyStr) != 16 {
		return 0, fmt.Errorf("error key len %d", len(keyStr))
	}
	keyBytes, err := hex.DecodeString(keyStr)
	if err != nil {
		return 0, fmt.Errorf("DecodeString: %v", err)
	}
	
	if len(keyBytes) != 8 {
		return 0, fmt.Errorf("len(keyBytes) != 8")
	}
	return binary.BigEndian.Uint64(keyBytes), nil
}

func generateAndSaveKey(keyFilePath string) (uint64, error) {
	keyBytes := make([]byte, 8)
	_, err := rand.Read(keyBytes)
	if err != nil {
		return 0, fmt.Errorf("err: %v", err)
	}
	key := binary.BigEndian.Uint64(keyBytes)
	keyHex := hex.EncodeToString(keyBytes)
	err = os.WriteFile(keyFilePath, []byte(keyHex), 0600) 
	if err != nil {
		return 0, fmt.Errorf("err: %v", err)
	}
	return key, nil
}

\end{lstlisting}


%
%
%В данном разделе описывается анализ предметной области базы данных музея, формализация задачи и выбор базы данных по модели хранения.
%
%\section{Анализ предметной области}
%
%
%В данной работе под словом музей понимается учреждение, занимающееся хранением и выставлением на обозрение произведений искусства. Произведением искусства может считаться любой объект, имеющий эстетическую и историческую ценность. Поэтому разные музеи хранят разного рода объекты и на сайтах называют их по разному, например, экспонаты, шедевры, картины, произведения, объекты.
%Для создания базы данных музея были рассмотрены аналоги, которые представлены в виде информации на сайте Третьяковской галереи, Пушкинского музея, Эрмитажа и Лувра.
%
%\subsection{Третьяковская галерея}
%
%\subsection{Сравнение аналогов}
%Для сравнения описанных выше аналогов хранилищ произведений искусства были выбраны критерии:
%\begin{enumerate}[label={\arabic*)}]
%	\item характеристики произведений искусства представленные на сайте;
%	\item параметры сортировки экспонатов;	
%	\item параметры фильтрации экспонатов;	
%	\item наличие информации о местоположении картин;	
%	\item наличие информации о предстоящих выставках;	
%%	\item наличие выпадающего списка в фильтрах;	
%%	\item возможность увидеть полную информацию о произведении искусства;
%	\item наличие информации о текущих выставках;
%	\item возможность приобретения билетов на выставки;
%%	\item возможность спонсорства (программа “Друг музея”);
%\end{enumerate}
%
%\begin{longtable}{|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%	}
%	\caption{Сравнение аналогов}\label{tbl:cmpAnalogues} \\\hline
%	 Критерии сравнения & Третьяковская галерея & Эрмитаж & Пушкинский музей & Лувр \\\hline    
%	 \endfirsthead
%	 \caption*{Продолжение таблицы~\ref{tbl:cmpAnalogues} } \\\hline
%	 Критерии сравнения & Третьяковская галерея & Эрмитаж & Пушкинский музей & Лувр \\\hline           
%	\endhead
%	\endfoot
%	
%	1 	& Название, автор, период создания, инвентарный номер, размер, материал, техника  
%		& Название, автор, период создания, инвентарный номер, размер, материал, техника  
%		& Название, автор, период создания, инвентарный номер, размер, материал, коллекция, страна, прежний владелец 
%		& Название, автор, период создания, инвентарный номер, размер, материал, техника, коллекция, страна, прежний владелец, местоположение \\\hline
%		
%	2 	& Название, автор, период 
%		& Нет возможности сортировки 
%		& Автор, период создания
%		& Название, автор, период создания, коллекция, актуальность, инвентарный номер \\\hline
%
%	3 	& Название, автор, категория, период, тип 
%		& Название, автор, период создания, инвентарный номер, размер, материал, техника  
%		& Название, автор, коллекция, страна, наличие изображения, прежний владелец
%		& Название, автор, период создания, коллекция, местонахождения \\\hline
%	4 & Нет & Нет & Только о присутствии/отсутствии в залах музея & Есть \\\hline
%	5 & - & + & + & -\\\hline
%	6 & + & + & + & +\\\hline
%	7 & + & + & + & +\\\hline
%%	5 & + & - & + & +\\\hline наличие выпадающего списка в фильтрах;	
%%	6 & + & + & + & +\\\hline возможность увидеть полную информацию о произведении искусства;
%%	9 & + & + & + & +\\\hline возможность спонсорства (программа “Друг музея”);
%	
%\end{longtable}
%
%\clearpage
%  
%%\imgw{\widthone\textwidth}{img/user-case-3}{Пользователи базы данных}
%\FloatBarrier
%%\textit{Рисунок -- Пользователи базы данных}
%
%\clearpage
%
%\section{Выбор базы данных по модели хранения}
%
%По модели хранения данных БД разделяют на 3 типа~\cite{introDBsys}:
%
%\begin{itemize}
%	\item \textbf{Дореляционные базы данных}. Данные формируются в виде структур, наиболее известными примерами которых являются инвертированные списки, деревья и графы. На основе этого определяется способ доступа к данным и работа с ними, в большинстве случаем используются указатели.
%%	представляют из себя ранние системы управления данными, включающие инвертированные списки (данные в файлах с индексами), иерархические (организация в виде дерева) и сетевые (представление в виде графа) модели. Они менее гибкие, сложнее в управлении и не поддерживали строгих ограничений целостности, в отличие от реляционных баз данных;
%%	
%	\item \textbf{Реляционные базы данных}. Данные формируются в виде взаимосвязанных таблиц (отношений), где каждая строка представляет запись, а столбцы -- атрибуты. Работа с данным возможна двумя способами: с использованием реляционной алгебры и реляционных исчислений. Накладываются четкие ограничения на формат представления данных в виде записей с фиксированным количеством атрибутов.
%%	организуют данные в виде таблиц (отношений), где каждая строка представляет запись, а столбцы — атрибуты. Такая модель состоит из трех основных компонент: структурной (описывает из каких объектов строится реляционная модель), целостной (определяет 2 базовых требования целостности -- целостность сущности и ссылочную целостность) и манипуляционной (описывает 2 эквивалентных способа манипулирования реляционными данными -- реляционную алгебру и реляционное исчисление);
%	\item \textbf{Постреляционные базы данных}. Данные представляются в виде объектов (таблиц), которые могут быть вложенными и содержать переменное количество полей. За счет этого возможно построение зависимостей одних данных от других и создание иерархии.
%	
%%	преодолевают ограничения реляционной модели. Они поддерживают гибкие структуры данных (документы, графы, ключ-значение), обеспечивают высокую производительность, масштабируемость и отказоустойчивость, подходят для больших объемов данных, неструктурированной информации и специализированных задач.;
%\end{itemize}
%
%На основе формализации поставленной задачи и в отсутствии необходимости поддержки гибких иерархичных структур данных была выбрана реляционная модель.
%
%%для реализации зависимостей выделенных элементов друг от друга и так как нет необходимости в поддержке гибких структуры данных, была выбрана реляционная модель.
%
%
%\section*{Вывод}
%В данном разделе были представлены: формализация задачи, анализ предметной области базы данных музея в виде информации на сайте Третьяковской галереи, Пушкинского музея, Эрмитажа и Лувра. Также была выбрана реляционная модель базы данных.
