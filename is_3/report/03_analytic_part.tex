\chapter{Теоретическая часть}

Асимметричное шифрование — это метод шифрования данных, при котором используются два ключа: открытый и закрытый. Ключи связаны математически: то, что зашифровано одним, может быть расшифровано только другим. 

Открытый (публичный) ключ используется для шифрования данных, может быть известен всем.

Закрытый (приватный) ключ используется для расшифровки данных, зашифрованных открытым ключом.


\chapter{Описание алгоритма шифрования и расшифровки с открытым ключом файла}

На рисунке~\ref{img:img/genKeys_rsa} приведена схема генерации ключевой пары.

\FloatBarrier
\imgw{0.5\textwidth}{img/genKeys_rsa}{Схема генерации ключевой пары}
\FloatBarrier

На рисунке~\ref{img:img/encr_rsa} приведена схема алгоритма шифрования с открытым ключом.

\FloatBarrier
\imgw{0.5\textwidth}{img/encr_rsa}{Схема алгоритма шифрования с открытым ключом}
\FloatBarrier

На рисунке~\ref{img:img/decr_rsa} приведена схема алгоритма расшифровки с открытым ключом.

\FloatBarrier
\imgw{0.5\textwidth}{img/decr_rsa}{Схема алгоритма расшифровки с открытым ключом}
\FloatBarrier

\chapter{Пример работы алгоритма шифрования и расшифровки с открытым ключом файла}

На рисунке~\ref{img:img/successExample} приведен пример работы алгоритма шифрования и расшифровки с открытым ключом файла.

\FloatBarrier
\imgw{1\textwidth}{img/successExample}{Пример работы алгоритма шифрования и расшифровки с открытым ключом файла}
\FloatBarrier

\clearpage
На рисунке~\ref{img:img/errExample} приведен пример работы алгоритма шифрования и расшифровки с открытым ключом файла при попытке расшифровки файла сторонним ключом.

\FloatBarrier
\imgw{1\textwidth}{img/errExample}{Пример работы алгоритма шифрования и расшифровки с открытым ключом файла при попытке расшифровки файла сторонним ключом}
\FloatBarrier

\chapter{Реализация алгоритма шифрования и расшифровки с открытым ключом файла}
В качестве средства реализации алгоритма шифрования и расшифровки с открытым ключом файла был выбран язык Go.

\begin{lstlisting}[style=golang, caption={Реализация алгоритма шифрования и расшифровки с открытым ключом файла}, label=lst:codegolang]
type RSA struct {
	publicKey  *PublicKey
	privateKey *PrivateKey
	keysFile   string
}

type PublicKey struct {
	E *big.Int
	N *big.Int
}

type PrivateKey struct {
	D *big.Int
	N *big.Int
}

func NewRSA(loadKeys bool, keysFileName string) (*RSA, error) {
	rsa := &RSA{
		keysFile: keysFileName,
	}
	
	if loadKeys && FileExists(rsa.keysFile) {
		rsa.loadKeys()
	} else {
		rsa.generateKeys()
		err := rsa.saveKeys()
		if err != nil {
			return nil, fmt.Errorf("NewRSA: %w", err)
		}
	}
	
	return rsa, nil
}

func (r *RSA) generatePrime(min, max int64) *big.Int {
	for {
		n, err := rand.Int(rand.Reader, big.NewInt(max-min+1))
		if err != nil {
			panic(err)
		}
		n.Add(n, big.NewInt(min))
		
		if n.ProbablyPrime(20) {
			return n
		}
	}
}

func (r *RSA) generateKeys() {
	p := r.generatePrime(100, 300)
	q := r.generatePrime(100, 300)
	for p.Cmp(q) == 0 {
		q = r.generatePrime(100, 300)
	}
	
	n := new(big.Int).Mul(p, q)
	phi := new(big.Int).Mul(
	new(big.Int).Sub(p, big.NewInt(1)),
	new(big.Int).Sub(q, big.NewInt(1)),
	)
	
	e := big.NewInt(65537)
	for new(big.Int).GCD(nil, nil, e, phi).Cmp(big.NewInt(1)) != 0 {
		e, _ = rand.Int(rand.Reader, new(big.Int).Sub(phi, big.NewInt(3)))
		e.Add(e, big.NewInt(3))
	}
	
	d := new(big.Int).ModInverse(e, phi)
	
	r.publicKey = &PublicKey{E: e, N: n}
	r.privateKey = &PrivateKey{D: d, N: n}
}

func (r *RSA) saveKeys() error {
	keys := map[string]interface{}{
		"public_key": map[string]string{
			"e": r.publicKey.E.String(),
			"n": r.publicKey.N.String(),
		},
		"private_key": map[string]string{
			"d": r.privateKey.D.String(),
			"n": r.privateKey.N.String(),
		},
	}
	
	jsonData, err := json.MarshalIndent(keys, "", "  ")
	if err != nil {
		return fmt.Errorf("saveKeys: %w", err)
	}
	
	err = os.WriteFile(r.keysFile, jsonData, 0644)
	if err != nil {
		return fmt.Errorf("saveKeys: %w", err)
	}
	return nil
}

func (r *RSA) loadKeys() {
	data, err := os.ReadFile(r.keysFile)
	if err != nil {
		panic(err)
	}
	
	var keys map[string]interface{}
	err = json.Unmarshal(data, &keys)
	if err != nil {
		panic(err)
	}
	
	publicKey := keys["public_key"].(map[string]interface{})
	e := new(big.Int)
	e.SetString(publicKey["e"].(string), 10)
	n := new(big.Int)
	n.SetString(publicKey["n"].(string), 10)
	r.publicKey = &PublicKey{E: e, N: n}
	
	privateKey := keys["private_key"].(map[string]interface{})
	d := new(big.Int)
	d.SetString(privateKey["d"].(string), 10)
	n = new(big.Int)
	n.SetString(privateKey["n"].(string), 10)
	r.privateKey = &PrivateKey{D: d, N: n}
}

func (r *RSA) encryptByte(b byte) *big.Int {
	byteInt := big.NewInt(int64(b))
	return new(big.Int).Exp(byteInt, r.publicKey.E, r.publicKey.N)
}

func (r *RSA) decryptByte(encrypted *big.Int) byte {
	decrypted := new(big.Int).Exp(encrypted, r.privateKey.D, r.privateKey.N)
	return byte(decrypted.Int64())
}

func (r *RSA) EncryptFile(inputPath, outputPath string) error {
	inputFile, err := os.Open(inputPath)
	if err != nil {
		return err
	}
	defer inputFile.Close()
	
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer outputFile.Close()
	
	buffer := make([]byte, 1)
	for {
		_, err := inputFile.Read(buffer)
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		
		encrypted := r.encryptByte(buffer[0])
		encryptedBytes := encrypted.Bytes()
		
		length := byte(len(encryptedBytes))
		if _, err := outputFile.Write([]byte{length}); err != nil {
			return err
		}
		if _, err := outputFile.Write(encryptedBytes); err != nil {
			return err
		}
	}
	
	return nil
}

func (r *RSA) DecryptFile(inputPath, outputPath string) error {
	inputFile, err := os.Open(inputPath)
	if err != nil {
		return err
	}
	defer inputFile.Close()
	
	outputFile, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer outputFile.Close()
	
	for {
		lengthBuf := make([]byte, 1)
		_, err := inputFile.Read(lengthBuf)
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		
		length := int(lengthBuf[0])
		if length == 0 {
			continue
		}
		
		encryptedBytes := make([]byte, length)
		_, err = inputFile.Read(encryptedBytes)
		if err != nil {
			return err
		}
		
		encrypted := new(big.Int).SetBytes(encryptedBytes)
		decrypted := r.decryptByte(encrypted)
		
		if _, err := outputFile.Write([]byte{decrypted}); err != nil {
			return err
		}
	}
	
	return nil
}

\end{lstlisting}


%
%
%В данном разделе описывается анализ предметной области базы данных музея, формализация задачи и выбор базы данных по модели хранения.
%
%\section{Анализ предметной области}
%
%
%В данной работе под словом музей понимается учреждение, занимающееся хранением и выставлением на обозрение произведений искусства. Произведением искусства может считаться любой объект, имеющий эстетическую и историческую ценность. Поэтому разные музеи хранят разного рода объекты и на сайтах называют их по разному, например, экспонаты, шедевры, картины, произведения, объекты.
%Для создания базы данных музея были рассмотрены аналоги, которые представлены в виде информации на сайте Третьяковской галереи, Пушкинского музея, Эрмитажа и Лувра.
%
%\subsection{Третьяковская галерея}
%
%\subsection{Сравнение аналогов}
%Для сравнения описанных выше аналогов хранилищ произведений искусства были выбраны критерии:
%\begin{enumerate}[label={\arabic*)}]
%	\item характеристики произведений искусства представленные на сайте;
%	\item параметры сортировки экспонатов;	
%	\item параметры фильтрации экспонатов;	
%	\item наличие информации о местоположении картин;	
%	\item наличие информации о предстоящих выставках;	
%%	\item наличие выпадающего списка в фильтрах;	
%%	\item возможность увидеть полную информацию о произведении искусства;
%	\item наличие информации о текущих выставках;
%	\item возможность приобретения билетов на выставки;
%%	\item возможность спонсорства (программа “Друг музея”);
%\end{enumerate}
%
%\begin{longtable}{|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%		>{\centering\arraybackslash}m{.2\textwidth - 2\tabcolsep}|
%	}
%	\caption{Сравнение аналогов}\label{tbl:cmpAnalogues} \\\hline
%	 Критерии сравнения & Третьяковская галерея & Эрмитаж & Пушкинский музей & Лувр \\\hline    
%	 \endfirsthead
%	 \caption*{Продолжение таблицы~\ref{tbl:cmpAnalogues} } \\\hline
%	 Критерии сравнения & Третьяковская галерея & Эрмитаж & Пушкинский музей & Лувр \\\hline           
%	\endhead
%	\endfoot
%	
%	1 	& Название, автор, период создания, инвентарный номер, размер, материал, техника  
%		& Название, автор, период создания, инвентарный номер, размер, материал, техника  
%		& Название, автор, период создания, инвентарный номер, размер, материал, коллекция, страна, прежний владелец 
%		& Название, автор, период создания, инвентарный номер, размер, материал, техника, коллекция, страна, прежний владелец, местоположение \\\hline
%		
%	2 	& Название, автор, период 
%		& Нет возможности сортировки 
%		& Автор, период создания
%		& Название, автор, период создания, коллекция, актуальность, инвентарный номер \\\hline
%
%	3 	& Название, автор, категория, период, тип 
%		& Название, автор, период создания, инвентарный номер, размер, материал, техника  
%		& Название, автор, коллекция, страна, наличие изображения, прежний владелец
%		& Название, автор, период создания, коллекция, местонахождения \\\hline
%	4 & Нет & Нет & Только о присутствии/отсутствии в залах музея & Есть \\\hline
%	5 & - & + & + & -\\\hline
%	6 & + & + & + & +\\\hline
%	7 & + & + & + & +\\\hline
%%	5 & + & - & + & +\\\hline наличие выпадающего списка в фильтрах;	
%%	6 & + & + & + & +\\\hline возможность увидеть полную информацию о произведении искусства;
%%	9 & + & + & + & +\\\hline возможность спонсорства (программа “Друг музея”);
%	
%\end{longtable}
%
%\clearpage
%  
%%\imgw{\widthone\textwidth}{img/user-case-3}{Пользователи базы данных}
%\FloatBarrier
%%\textit{Рисунок -- Пользователи базы данных}
%
%\clearpage
%
%\section{Выбор базы данных по модели хранения}
%
%По модели хранения данных БД разделяют на 3 типа~\cite{introDBsys}:
%
%\begin{itemize}
%	\item \textbf{Дореляционные базы данных}. Данные формируются в виде структур, наиболее известными примерами которых являются инвертированные списки, деревья и графы. На основе этого определяется способ доступа к данным и работа с ними, в большинстве случаем используются указатели.
%%	представляют из себя ранние системы управления данными, включающие инвертированные списки (данные в файлах с индексами), иерархические (организация в виде дерева) и сетевые (представление в виде графа) модели. Они менее гибкие, сложнее в управлении и не поддерживали строгих ограничений целостности, в отличие от реляционных баз данных;
%%	
%	\item \textbf{Реляционные базы данных}. Данные формируются в виде взаимосвязанных таблиц (отношений), где каждая строка представляет запись, а столбцы -- атрибуты. Работа с данным возможна двумя способами: с использованием реляционной алгебры и реляционных исчислений. Накладываются четкие ограничения на формат представления данных в виде записей с фиксированным количеством атрибутов.
%%	организуют данные в виде таблиц (отношений), где каждая строка представляет запись, а столбцы — атрибуты. Такая модель состоит из трех основных компонент: структурной (описывает из каких объектов строится реляционная модель), целостной (определяет 2 базовых требования целостности -- целостность сущности и ссылочную целостность) и манипуляционной (описывает 2 эквивалентных способа манипулирования реляционными данными -- реляционную алгебру и реляционное исчисление);
%	\item \textbf{Постреляционные базы данных}. Данные представляются в виде объектов (таблиц), которые могут быть вложенными и содержать переменное количество полей. За счет этого возможно построение зависимостей одних данных от других и создание иерархии.
%	
%%	преодолевают ограничения реляционной модели. Они поддерживают гибкие структуры данных (документы, графы, ключ-значение), обеспечивают высокую производительность, масштабируемость и отказоустойчивость, подходят для больших объемов данных, неструктурированной информации и специализированных задач.;
%\end{itemize}
%
%На основе формализации поставленной задачи и в отсутствии необходимости поддержки гибких иерархичных структур данных была выбрана реляционная модель.
%
%%для реализации зависимостей выделенных элементов друг от друга и так как нет необходимости в поддержке гибких структуры данных, была выбрана реляционная модель.
%
%
%\section*{Вывод}
%В данном разделе были представлены: формализация задачи, анализ предметной области базы данных музея в виде информации на сайте Третьяковской галереи, Пушкинского музея, Эрмитажа и Лувра. Также была выбрана реляционная модель базы данных.
